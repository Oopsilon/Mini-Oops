The Need for a Critical Programming Language
============================================

Alan Kay is famously said to have tried to restart work on Smalltalk several
times. Accounts are related of him wanting to "burn the disk packs" around the
Smalltalk-76 era, only being dissauded from doing so by others who worked on
Smalltalk with him. Times have changed since then: software is a lot messier.
Modern systems are built on the debris of decades of deadwood.

There is a contradiction here though. At the same time, there *is* a
recognition of inadequacies in the current ways. Two streams of languages which
try to address these inadequacies are growing at the time of this being written:

- the functional languages like Haskell and Agda;
- and the dynamic languages like Python and Ruby.

It may sound as though the two families are as far apart as possible. But both
are trying to make programming a more expressive endeavour, and both are driven
by a real idealism, a belief that we can do better than the model of the "suit
and tie" languages.

A language that is to be a true advance on its predecessors must be certain to
look at why the disciples of languages in one of these two families tend to be
very passionate about their language and what it enables. We need to consider
what these languages reveal as inadequate in programming today - then we need
to look at how these languages themselves can be improved upon.

Determinate Negation
~~~~~~~~~~~~~~~~~~~~

Above all, we must be relentlessly *negative*. That is to say, we must submit
to analysis every piece of received wisdom, every bit of 'common sense,' every
'proper convention,' every suggestion that 'we can't do any better,' and every
impossibility. This is the root of reason itself.

Before anything new can be built, the problems of the old have to be laid bare.
We can work out what the new will look like on the basis of what it will *not*
look like.